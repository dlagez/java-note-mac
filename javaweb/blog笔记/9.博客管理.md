先修改了一下页面的细节

### service层

blogService.java

```java
public interface BlogService {
		// 1 获取
    Blog getBlogById(Long id);
		
		// 1 查询条件封装成一个blog对象
    Page<Blog> listBlog(Pageable pageable, BlogQuery blog);
		
		// 1 保存
    Blog saveBlog(Blog blog);

		// 1 更新
    Blog updateBlog(Long id, Blog blog);
    // 1 删除
    void deleteBlog(Long id);
}
```

### Repository

BlogRepository.java

JpaSpecificationExecutor<Blog> 继承这个借口是为了使用组合查询。

```java
public interface BlogRepository extends JpaRepository<Blog, Long>,
        JpaSpecificationExecutor<Blog> {
}
```

### BlogServiceImpl

BlogServiceImpl.java

完成了基本的增删改查，其中listBlog比较复杂，因为不仅仅是将博客列表查询出来，还要实现条件查询

```java
@Service
public class BlogServiceImpl implements BlogService {

    @Autowired
    private BlogRepository blogRepository;

    @Override
    public Blog getBlogById(Long id) {
        return blogRepository.getById(id);
    }

    // 分页查询 动态查询
    @Override
    public Page<Blog> listBlog(Pageable pageable, BlogQuery blog) {
        // 第一个参数：new Specification<Blog>() 处理查询条件的
        // Root<Blog> root 要查询的对象，获取到表的一些字段
        // CriteriaQuery<?> cq 查询条件的容器，可以把条件放到这个里面去
        // CriteriaBuilder cb 设置条件的表达式
        // 第二个参数：pageable
       return blogRepository.findAll(new Specification<Blog>() {
            @Override
            public Predicate toPredicate(Root<Blog> root, CriteriaQuery<?> cq, CriteriaBuilder cb) {
                // 动态查询分页，增加条件查询的列表
                List<Predicate> predicates = new ArrayList<>();
                // 如果有title不为空，将title加入查询，并使用 like 语句， 下同
                if (!"".equals(blog.getTitle()) && blog.getTitle() != null) {
                    predicates.add(cb.like(root.<String>get("title"), "%"+blog.getTitle()+"%"));
                }
                if (blog.getTypeId() != null) {
                    predicates.add(cb.equal(root.<Type>get("type").get("id"), blog.getTypeId()));
                }
                if (blog.isRecommend()) {
                    predicates.add(cb.equal(root.<Boolean>get("recommend"), blog.isRecommend()));
                }
                cq.where(predicates.toArray(new Predicate[predicates.size()]));
                return null;
            }
        }, pageable);
        
    }


    // 保存对象
    @Override
    public Blog saveBlog(Blog blog) {
        return blogRepository.save(blog);
    }

    // 修改对象
    @Override
    public Blog updateBlog(Long id, Blog blog) {
        Blog b = blogRepository.getById(id);
        if (b == null) {
            throw new RuntimeException("修改对象不存在");
        }
        BeanUtils.copyProperties(b, blog);
        return blogRepository.save(b);
    }

    @Override
    public void deleteBlog(Long id) {
        blogRepository.deleteById(id);
    }
}

```

### Controller

BlogController.java

实现视图层，参数是分页参数，将查询条件自动封装成一个blogQuery对象（Blog对象不行），还有视图模型。

```java
@Controller
@RequestMapping("/admin")
public class BlogController {

    @Autowired
    private BlogService blogService;

    @GetMapping("/blogs")
    public String blogs(@PageableDefault(size = 2, sort = {"updateTime"}, direction = Sort.Direction.DESC)
                                    Pageable pageable, BlogQuery blog, Model model) {
        model.addAttribute("page", blogService.listBlog(pageable, blog));
        return "admin/blogs";
    }
}
```

### blog页面

blog.html

通过thmeleaf语句可以将后台拿到的数据填充到页面上，

这里有个问题就是：

我们点击上一页下一页的时候，只是携带了页码数，如果我们是按照条件查询的话，不能携带查询的条件。

解决方法：使用ajax局部刷新页面即可。这样在翻页显示数据的情况下保证了查询条件不会消失

```html
<div class="ui secondary segment form">
        <!--   这个input控制第几页    -->
        <input type="hidden" name="page">
        <div class="inline fields">
          <div class="field">
            <input type="text" name="title" placeholder="标题">
          </div>
          <div class="field">
            <div class="ui labeled action input">
              <div class="ui selection dropdown">
                <input type="hidden" name="typeId">
                <i class="dropdown icon"></i>
                <div class="default text">分类</div>
                <div class="menu">
                  <!--    这个分类是选择项目，我们在进入这个页面的时候将数据库存储的所有类型都加载到页面显示      -->
                  <div th:each="type : ${types}" class="item" data-value="1" th:data-value="${type.id}"
                       th:text="${type.name}">错误日志</div>
                  <!--   下面的可以删除，为了保持静态html也能正常显示，所以用专门的注释括起来      -->
                  <!--/*-->
                  <div class="item" data-value="2">开发者手册</div>
                  <!--*/-->
                </div>
              </div>
              <button id="clear-btn" class="ui compact button">clear</button>
            </div>


          </div>
          <div class="field">
            <div class="ui checkbox">
              <input type="checkbox" id="recommend" name="recommend">
              <label for="recommend">推荐</label>
            </div>
          </div>
          <div class="field">
            <button type="button" id="search-btn" class="ui mini teal basic button"><i class="search icon"></i>搜索</button>
          </div>
        </div>
      </div>

...........
    
<!--th:fragment="blogList" 使用ajax请求，局部修改这个部分的页面-->
<table th:fragment="blogList" class="ui compact teal table">
  <thead>
  <tr>
    <th></th>
    <th>标题</th>
    <th>类型</th>
    <th>推荐</th>
    <th>更新时间</th>
    <th>操作</th>
  </tr>
  </thead>
  <tbody>
  <tr th:each="blog, iterStat : ${page.content}">
    <td th:text="${iterStat.count}">1</td>
    <td th:text="${blog.title}">刻意练习清单</td>
    <td th:text="${blog.type.name}">认知升级</td>
    <td th:text="${blog.recommend} ? '是':'否'">是</td>
    <td th:text="${blog.updateTime}">2017-10-02 09:45</td>
    <td>
      <a href="#" th:href="@{/admin/blogs/{id}/input(id=${blog.id})}" class="ui mini teal basic button">编辑</a>
      <a href="#" th:href="@{/admin/blogs/{id}/delete(id=${blog.id})}" class="ui mini red basic button">删除</a>
    </td>
  </tr>
  </tbody>
  <tfoot>
  <tr>
    <th colspan="7">
      <div class="ui mini pagination menu" th:if="${page.totalPages}>1">
        <!--     th:attr="data-page=${page.number-1}" 自定义属性 解析完之后就会变成 data.page=1        -->
        <!--    上下翻页其实是使用了ajax技术。先将这里自定义属性赋值到隐藏域input，然后再使用ajax附带条件请求       -->
        <a onclick="page(this)" th:attr="data-page=${page.number-1}" class=" item" th:unless="${page.first}">上一页</a>
        <a onclick="page(this)" th:attr="data-page=${page.number+1}" class=" item" th:unless="${page.last}">下一页</a>
      </div>
      <a href="#" th:href="@{/admin/blogs/input}" class="ui mini right floated teal basic button">新增</a>
    </th>
  </tr>
  </tfoot>
</table>



<script>
  	// 上下翻页的实现
    function page(obj) {
      // $("[name='page']") 获取到name=page的隐含域，然后给他赋值，就是上一页下一页的页码数，page=1之类
      // 就是我们在上一页按钮上自定义了一个属性，叫data.page 它控制当前第几页，
      // 下面的语句将点击完下一页之后的page数赋值给page
      $("[name='page']").val($(obj).data("page"));
      loaddata();
    }
  
  // 搜索的点击触发方法
    $("#search-btn").click(function () {
      // 搜索没有页面信息，所以这里直接赋值第0页
      $("[name='page']").val(0);
      loaddata();
    });
  
  // 加载数据的方法,这个方法会将title，page等信息带到后台
  // 加载数据的方法
    function loaddata() {
      // load方法是请求一个地址
      // /*[[@{/admin/blogs/search}]]*/ 模板会将它解析成要访问的地址
      $("#table-container").load(/*[[@{/admin/blogs/search}]]*/"/admin/blogs/search",{
        title : $("[name='title']").val(),
        typeId : $("[name='typeId']").val(),
        recommend : $("[name='recommend']").prop('checked'),
        page : $("[name='page']").val()
      });
    }
  </script>
```

到这里功能基本都已经实现了，但是有个问题就是：

下面的这个分页查询，就是博客查询需要附带一个类型信息。而我们直接进入页面的时候是没有类型信息的（因为没有查询条件）。类型信息是页面上的查询条件带到后台用来封装成blog，然后使用这些信息进行分页查询。所以到这里还不能运行，视频上的解决方案是将查询条件不封装成blog类型，而是针对查询的条件，再定义一个实体类专门用来进行查询。

```java
// 分页查询 动态查询
    @Override
    public Page<Blog> listBlog(Pageable pageable, BlogQuery blog) {
        // 第一个参数：new Specification<Blog>() 处理查询条件的
        // Root<Blog> root 要查询的对象，获取到表的一些字段
        // CriteriaQuery<?> cq 查询条件的容器，可以把条件放到这个里面去
        // CriteriaBuilder cb 设置条件的表达式
        // 第二个参数：pageable
        blogRepository.findAll(new Specification<Blog>() {
            @Override
            public Predicate toPredicate(Root<Blog> root, CriteriaQuery<?> cq, CriteriaBuilder cb) {
                // 动态查询分页，增加条件查询的列表
                List<Predicate> predicates = new ArrayList<>();
                // 如果有title不为空，将title加入查询，并使用 like 语句， 下同
                if (!"".equals(blog.getTitle()) && blog.getTitle() != null) {
                    predicates.add(cb.like(root.<String>get("title"), "%"+blog.getTitle()+"%"));
                }
                if (blog.getTypeId() != null) {
                    predicates.add(cb.equal(root.<Type>get("type").get("id"), blog.getTypeId()));
                }
                if (blog.isRecommend()) {
                    predicates.add(cb.equal(root.<Boolean>get("recommend"), blog.isRecommend()));
                }
                cq.where(predicates.toArray(new Predicate[predicates.size()]));
                return null;
            }
        }, pageable);
        return null;
    }
```

所以现在重新定义一个查询类，将查询的条件都改成BlogQuery即可。

```java
package com.roczhang.blog.vo;

// 专门用来查询的实体类型
public class BlogQuery {
    private String title;
    private Long typeId;
    private boolean recommend;

   geter,setter.....
}
```

