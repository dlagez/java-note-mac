## 选择优化的数据类型

### 有以下几个原则：

- 更小的通常更好：更小的数据类型通常更快。
- 简单就好：简单的数据类型通常需要更少的CPU周期，整型比字符型操作代价更低。
- 尽量避免null：

### 整数类型：

整数：（whole number）TINYINT， SMALLINT，MEDIUMINT，INT，BIGINT。

分别使用8， 16，24，32，64位存储空间。

整数由可选的UNSIGNED属性，表示不允许为负值，大致可以使得正数的范围提升一倍。

INT（11）只是限制显示的范围，对于存储来说，他们是一样的。

### 实数类型：

DECIMAL存储比BIGINT还大的整数

### 字符串类型：

VARCHAR：存储可变长字符串，比定长的字符串char类型节省空间。

适合：字符串列的最大长度比平均长度大很多。列的更新很少。

CHAR：定长，mysql会删除所有的末尾空格

适合：存储很短的字符串，或者所有值都接近同一个长度。



### BLOB和TEXT类型

为了存储很大的数据而设计的，分别采用二进制和字符方式存储

排序之用到了前面的几个字节，而不是全部的字节



### 使用枚举类ENUM代替字符串类型

存储的是整数，在.frm文件中保存“数字-字符串”映射关系的查找表。



### 日期和时间类型

DATATIME：能保存大范围的值，精度为秒

TIMESTAMP：使用四个字节的存储空间



### 位数据类型：

它使用紧凑的位存储数据

BIT：mysql5之后，可以使用它在一列中存储一个或者多个true/false值。

SET：需要保存很多true/false值

### 选择表示符：

标识列应该与相关表中使用相同的数据类型。

MySql内部使用整数存储ENUM和SET类型，然后在做比较操作时转换为字符串。

- 整数类型：是表识列最好的选择，可以AUTO_INCREMENT
- ENUM和SET类型：是个糟糕的选择

## MySQL schema 设计中的陷阱

### 太多的列：

mysql的存储引擎API工作时需要在服务器和存储引擎之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。这个过程代价非常高。太多的列，但是只有一小部分会实际用到的话会导致效率低下。

### 太多的关联：

单个查询最好在12个表以内做关联。



