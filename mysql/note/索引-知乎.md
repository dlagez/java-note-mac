https://zhuanlan.zhihu.com/p/162363262

索引的优缺点：

**优点：**

1.大大加快数据的查询速度

2.唯一索引可以保证数据库表每一行的唯一性

3.加速表连接时间

**缺点：**

1.创建、维护索引要耗费时间，所以，索引数量不能过多。

2.索引是一种数据结构，会占据磁盘空间。

3.对表进行更新操作时，索引也要动态维护，降低了维护速度

## **哈希索引**

哈希表，也称散列表，主要设计思想是通过一个哈希函数， 把关键码映射的位置去寻找存放值的地方 ，读取的时候也是直接通过关键码来找到位置并存进去，这种数据结构的平均查找复杂度为O(1)。

优点：

- 添加和删除单个元素的效率高

缺点：

- 元素不是按顺序排列的，区间查询很慢。
- 只使用于等值查询

## **有序数组索引**

有序数组索引在等值查询和区间查询场景中的效率都很高

**适用于静态存储引擎**

优点：

- 查询区间很快，

缺点：

- 移动和删除元素很慢

比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。

## **搜索树索引**

二叉搜索树它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势，同时，因为本身二叉搜索树是有序的，所以也支持范围查找

缺点：读取节点需要磁盘IO，用来获取下一个节点，检索一个数据需要十几次的磁盘IO是很不划算的。

## **InnoDB的索引结构**

InnoDB是MySQL中最常用的搜索引擎，它的索引底层结构用的就是B+树，所有的数据都是存储在B+树中的。每一个索引在InnoDB中对应一颗B+树。

特点：

- 所有的叶子节点中包含了全部的信息，及指向含这些元素记录的指针，且叶子节点本身依关键字的大小自大而小顺序链接。
- 所有的中间节点元素都同时存在于子结点，在子结点元素中是最大或最小的元素。

优点：

- 可以使得单一节点存储更多的元素，除了叶子节点，其他的节点只是包含了键，没有保存值，这样的话，树的高度就能有效的降低，从而减少查询的IO次数。
- 叶子节点包含了下个叶子节点的指针，所以范围查询的时候如果搜索到第一个叶子结点的话，就能根据指针指向查询后面的数据，不用再从根结点遍历了。

## **索引的分类**

聚簇索引：聚集索引，同时叶子结点中存放的就是整张表的行记录数据。就是索引和数据放在一起。

非聚簇索引：二级索引，数据于索引分开存储，索引结构的叶子节点指向了数据对应的位置。

## **聚簇索引**

InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上

![img](%E7%B4%A2%E5%BC%95-%E7%9F%A5%E4%B9%8E.assets/v2-1c23e9411c34d9e36a2ab26dbd84884a_720w.jpg)

用图片表示InnoDB的索引结构大概是这样：

![img](%E7%B4%A2%E5%BC%95-%E7%9F%A5%E4%B9%8E.assets/v2-ec9779d6c9e6b9a04068b1d72a010814_720w.jpg)

从图中就可以看出，如果我们使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶结点，之后获得行数据。

若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）

## **非聚簇索引**

MyISM，这也是MySQL中常见的搜索引擎。

![img](%E7%B4%A2%E5%BC%95-%E7%9F%A5%E4%B9%8E.assets/v2-555c23d87fbb72d8cb9404b64155c99a_720w.jpg)

和聚簇索引一样，只是数据不再这颗树上面。

对比聚簇索引

1.查询快

> 聚簇索引中，由于行数据和叶子结点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，所以，如果按照主键Id来组织数据，获得数据更快。

就是因为索引和数据放在一起，查询索引的时候把数据一起查询到内存了。

2.对辅助索引影响小

> 辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作**，**使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"**。**也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），**使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。**

由于使用的地址值作为索引，所以当数据的地址值发生改变的时候（修改数据）辅助索引也需要变化。

3.聚簇索引适合用在排序、范围查询，非聚簇索引不适合。

## **覆盖索引**

说到辅助索引，我们还可以延伸出另一种特别的索引，就是**覆盖索引**。

上面说了，聚簇索引中访问数据要经过二次查找，就是先找到辅助键的叶子结点，得到主键对应的结点后再用主键索引查询数据，这样还是比较慢的，其实，如果我们所需的字段第一次查找就能获取到的话，就不用再二次查找主键了，也就是不用“回表”。

就还是上面那张表有三个字段id，name，company的表来说，我给**name**加了索引，在查询数据的时候，我就这么写语句：

```text
select name from user where name like '张%';
```

因为我们的语句走了索引，并且返回的字段在叶子结点都存在，查询的时候就不会回表了，多好啊~~

所以，如果所需的字段刚好是索引列的话，尽量用这种查询方式，不要用select *这种语句。

## **索引种类**

**普通索引**：这是最基本的索引类型，没唯一性之类的限制。

```text
CREATE INDEX INDEX_NAME ON TABLE_NAME(PROPERTY_NAME)
```

**唯一性索引**：和普通索引基本相同，但所有的索引列只能出现一次，保持唯一性。

```text
CREATE UNIQUE INDEX INDEX_NAME ON TABLE_NAME(PROPERTY_NAME)
```

**全文索引**：全文索引的索引类型为FULLTEXT，可以在VARCHAR或者TEXT类型的列上创建。在MySQL5.6以前的版本，只有 MyISAM 存储引擎支持全文索引，5.6及之后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引。

```text
CREATE FULLTEXT INDEX INDEX_NAME ON TABLE_NAME(PROPERTY_NAME)
```

**联合索引**：联合索引其实不是一种索引分类，就是包含多个字段的普通索引，比如有个联合索引为index(a，b)，查找的时候可以用 a and b 作为条件，

## **最左匹配原则**

联合索引中，最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。

就像上面说的index(a，b)或者是a单独作为查询条件都会走索引，但是如果是单独用 b 做查询条件就不会走索引了

或者是如果建立(a,b,c,d)顺序的索引的话，用a = 1 and b = 2 and c > 3 and d = 4这样的语句搜索，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。

## **索引什么时候会失效**

1、索引列用函数或表达式，比如这种

```text
select * from test where  num  +  1 = 5
```

2、存在NULL值条件

```text
select * from user where user_id is not null;
```

我们在设计数据库表时，应该尽力避免NULL值出现，如果数据有为空的情况可以给一个默认值，比如数值型的可以给0、-1，字符类型的可以给空字符串。

3、用or表达式作为条件，有一个列没有索引，那么其它列的索引将不起作用

```text
select * from user where user_id = 700 or user_name = "老薛";
```

像这种，如果user_id有加索引，而user_name没有的话，那么执行的时候user_id的索引也是失效的，这也是为什么开发中尽量少用or的原因，除非是两个字段都加了索引。

4、列与列对比，某个表中，有两列（id和c_id）都建了单独索引，下面这种查询条件不会走索引

```text
select * from test where id = c_id;
```

5、数据类型的转换。如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引

```text
create index `idx_user_name` ON user(user_name)
select * from user where user_name = 123;
```

像上面这种，虽然给user_name建立了索引，但查询的时候条件没有当成字符串，这样的话就不会走索引。

6、NOT条件

当查询条件为非时，索引定位就困难了，执行计划此时可能更倾向于全表扫描，这类的查询条件有：<>、NOT、in、not exists

```text
select * from user where user_id<>500;
select * from user where user_id in (1,2,3,4,5);
select * from user where user_id not in (6,7,8,9,0);
select * from user where user_id exists (select 1 from user_record where user_record.user_id = user.user_id);
```

7、like查询是以%开头

当使用模糊搜索时，尽量采用后置的通配符，例如要查姓张的人，可以用user_name like ‘张%’，这样走索引时，可以从前面开始匹配索引列，但如果是这样user_name like ‘%张’，那么就会走全表扫描的方式

8、多列索引，遵循最左匹配原则，这个上面说了

## **什么时候该用索引**

前面说了，索引虽然能加快查询速度，但本身也会占用空间，所以，索引的创建并不是越多越好，为了使索引能有效应用，我们要把索引留给最有用的查询字段，一般来说，应该在这些字段上创建索引：

- 主键字段，这不用多说了吧；
- 经常需要搜索的列，比如where条件经常用到的字段；
- 其他表的外键字段，作为连接表的条件字段，可以有效加快连表查询速度；
- 查询中作为排序、统计或者是分组的字段；

同样，对于有些字段不应该创建索引，这些列包括

- 频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件
- where条件里用不到的字段，不创建索引；
- 表记录太少，不需要创建索引；
- 对于那些定义为text，image类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少，不利于使用索引；
- 数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，这种字段建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。

注意：

1、索引要根据表数据的使用情况来创建，不能创建太多，一般一张表不建议超过6个索引字段

2、好刀要用在刀刃上，经常用于查询，没多少重复数据，搜索行数不超过表数据量4%的字段用索引的效果比较好

3、创建联合索引要注意最左匹配原则，切记，最左边的字段是必传字段，这点我他妈就吃过大亏

4、查询语句要用explain执行计划来查看性能。