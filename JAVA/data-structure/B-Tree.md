## B-Tree

数据库系统普遍采用`B-Tree`作为索引结构（例如`mysql`的`InnoDB`引擎使用的`B+`树）

平衡二叉树的查找效率非常高，并可以通过降低树的深度来提高查找效率，但是有两个问题限制了平衡二叉树的实际应用。

### 第一

当数据量非常大，树存储的元素数量是有限的，这样会导致**二叉查找树结构由于书的深度过大而造成磁盘`I/O`读写过于频繁，进而导致查询效率低下**。

### 第二

另外数据量过大会导致空间不够容纳平衡二叉树所有节点的情况。

B树可以很好的解决上述两个问题。

## 概念

B树和二叉树不同，B树是一种自平衡树，它维护有序数据并允许以对数时间进行数据的搜索，顺序访问，插入和删除。

B树是二叉搜索树的一般化，因为B树节点可以有两个以上的子节点，B树非常适合读取和写入相对较大的数据块（如光盘）的存储系统。它通常用于[数据库](https://en.wikipedia.org/wiki/Database)和[文件系统](https://en.wikipedia.org/wiki/File_system)。

## 定义

B树是一种平衡的多分树，通常我们说m阶的B树，它必须满足如下条件： 

- 每个节点最多只有m个子节点。
- 每个非叶子节点（除了根）具有至少⌈ m/2⌉子节点。
- 如果根不是叶节点，则根至少有两个子节点。
- 具有*k*个子节点的非叶节点包含*k* -1个键。
- 所有叶子都出现在同一水平，没有任何信息（高度一致）。

### 什么是B树的阶 ？

B树的阶：B树中的一个节点的**子节点数目**的最大值，用m表示。



这里加图片



### 什么是根节点 ？

特征：根节点拥有的子节点数量的上限和内部节点相同，如果根节点不是树中唯一节点的话，至少有俩个子节点

限制条件：2<= M <=m，M为子节点数量； 1<= K <=m-1,K为元素数量。

理解：比如一个5阶B树，它的根节点的子节点有个数限制，它的子节点只能在2-5个范围内，根节点包含的元素数量在1-4个范围内。

### 什么是内部节点 ？

特征：内部节点是除叶子节点和根节点之外的所有节点，拥有父节点和子节点。

理解：就是中间的节点，除了最上层和最下层的中间层。

假定m阶B树的内部节点的子节点数量为M，则一定要符合（m/2）<= M <=m关系式；（m/2）-1<= K <=m-1,K为包含的元素数量。m/2向上取整

### 什么是叶子节点？

特征：在m阶B树中叶子节点的元素符合（m/2）-1<= K <=m-1。

叶子节点对元素的数量有相同的限制，但是没有子节点，也没有指向子节点的指针。

理解：比如一个5阶B树，它的一个叶子节点的包含的元素有个数限制，它的叶子节点只能在1-4个范围内。

## 插入

针对m阶高度h的B树，插入一个元素时，首先需要确定该元素是否在B树中存在，如果不存在，即可在叶子节点中插入该新的元素。

- 若该节点元素个数小于m-1，直接插入；
- 若该节点元素个数等于m-1，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；
- 重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1；

使用例子来解释：

5阶B树关键点:

- 2<=根节点子节点个数<=5
- 3<=内节点子节点个数<=5
- 1<=根节点元素个数<=4
- 2<=非根节点元素个数<=4

此时有一个B树长下面这个样子：

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727135621105-1688663582.png)

现在往这个B树里面插入一个元素：8

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727150240628-562673561.png)

此时，根节点不满足B树的要求了！

此时根节点元素个数为5，不符合 1<=根节点元素个数<=4

需要进行分裂：取节点中间元素【7】，加入到父节点，左右分裂为2个节点，如下图。

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727150127189-82041957.png)

接着插入元素【5】，【11】，【17】时，不需要任何分裂操作，如图（4）

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727150529778-12220622.png)

插入元素【13】

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727150325549-653814900.png)

节点元素超出最大数量，进行分裂，提取中间元素【13】，插入到父节点当中，如图（6）

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727150403812-1196185160.png)



## 删除操作

感觉有点麻烦。

- 某结点中元素数目小于（m/2）-1,(m/2)向上取整，则需要看其某相邻兄弟结点是否丰满；
- 如果丰满（结点中元素个数大于(m/2)-1），则向父节点借一个元素来满足条件；
- 如果其相邻兄弟都不丰满，即其结点数目等于(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点；

接下来还以5阶B树为例，详细讲解删除的动作；

- 关键要领，元素个数小于 2（m/2 -1）就合并，大于4（m-1）就分裂

如图依次删除依次删除【8】,【20】,【18】,【5】

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727160351637-1629033369.png)

首先删除元素【8】，当然首先查找【8】，【8】在一个叶子结点中，删除后该叶子结点元素个数为2，符合B树规则，操作很简单，咱们只需要移动【11】至原来【8】的位置，移动【12】至【11】的位置（也就是结点中删除元素后面的元素向前移动）

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727160902710-1900336278.png)

下一步，删除【20】,因为【20】没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者【23】(字母升序的下个元素)，将【23】上移到【20】的位置，然后将孩子结点中的【23】进行删除，这里恰好删除后，该孩子结点中元素个数大于2，无需进行合并操作。

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727161905571-1441211802.png)

下一步删除【18】，【18】在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目2,而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中，在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素【23】下移到该叶子结点中，代替原来【19】的位置，【19】前移；然【24】在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除【24】，后面元素前移。

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727162837714-1263711630.png)

最后一步删除【5】， 删除后会导致很多问题，因为【5】所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素【4】下移到已经删除【5】而只有【6】的结点中，然后将含有【4】和【6】的结点和含有【1】,【3】的相邻兄弟结点进行合并成一个结点。

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727163249830-1144020179.png)

也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素【7】，没达标（因为非根节点包括叶子结点的元素K必须满足于2=<K<=4，而此处的K=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。而此时兄弟节点元素刚好为2，刚刚满足，只能进行合并，而根结点中的唯一元素【13】下移到子结点，这样，树的高度减少一层。

![img](https://cdn.jsdelivr.net/gh/dlagez/img@master/997909-20190727163912012-1560407429.png)

B+树去看下面的参考文章吧。





ref：https://www.cnblogs.com/lianzhilei/p/11250589.html