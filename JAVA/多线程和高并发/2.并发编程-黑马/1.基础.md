###  进程

- 程序由指令和数据组成，但是这些指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。进程就是用来加载指令、管理内存、管理IO的。
- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。

### 线程

- 一个进程之内可以分为一个到多个线程
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给cpu执行。
- Java中，线程作为最小调度单位，进程作为资源分配的最小单位

### 异步调用

从方法调用的角度来讲，如果

- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步

举例：同步方法，文件读取完之后才会执行日志记录

```java
 public static void main(String[] args) {
			FileReader.read(...);
			log.debug("do other things")
    }
```

异步方法:开启一个线程来执行读取文件，然后执行日志记录。

注意：由于开启线程需要时间，这个执行结果时先打印日志记录，然后打印文件读取完成。

```java
 public static void main(String[] args) {
			new Thread() -> FileReader.read(...).start();
			log.debug("do other things")
    }
```

### 设计

多线程可以让方法变成异步的，即执行程序的时候如果一个程序需要很长的时间来执行（比如视频格式转换需要一个小时），如果没有线程调度的机制，这一个小时我们什么也做不了，其他代码都得暂停。程序执行的这段我们不能干巴巴的等他执行完之后才去执行别的程序。所以我们开启一个新线程来执行这个程序。  

### 提高效率

多核cpu才能提高效率，单核cpu仍然是轮流执行。

### 结论

- 单核cpu下，为了能够在不同的任务之间切换，不同的线程轮流使用cpu
- 多核cpu可以并行跑多个程序，单能否提高程序运行效率还是要分情况的
  - 将任务拆分，并行执行，可以提高程序的运行效率，但不是所有计算任务都能拆分。
  - 不是所有任务都需要拆分
- IO操作不占用cpu，只是我们一般拷贝文件使用的是【阻塞IO】，这时相当于线程虽然不用cpu，但需要一直等待IO结束，没能充分利用线程。所以才有后面的【非阻塞IO】和【异步IO】优化。

### 创建线程的方法

#### Thread

我们运行main方法就是运行了一个主线程，如果我们还想运行其他线程，就可以自己创建线程。

线程的运行分两步：

```java
// 创建线程对象 
Thread t = new Thread() {
	public void run() {
	
	}
};
// 启动线程
t.start()
```

#### Runnable配合Thread

```java
// 创建任务
Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+" running");
            }
        };
// 将任务放入线程，并创建线程
Thread thread1 = new Thread(runnable);
thread1.setName("r1");
// 执行线程
thread1.start();
```

例子：

```java
public class demo1_thread {
    public static void main(String[] args) {
				// Thread
        Thread thread = new Thread() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+" running...");
            }
        };
        thread.start();

        //        runnable
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+" running");
            }
        };
        Thread thread1 = new Thread(runnable);
        thread1.setName("r1");
        thread1.start();
        System.out.println(Thread.currentThread().getName()+" running...");
    }
}
```

output:

```
Thread-0 running...
main running...
r1 running
```

### 小结：

1. 使用Runnable更容易和任务合并在一起。
2. Runnable让任务脱离了Thread继承体系，更灵活。 