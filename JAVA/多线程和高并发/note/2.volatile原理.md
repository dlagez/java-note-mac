## volatile的作用

并发编程中有3大重要特性，了解一下：

- 原子性

一个操作或者多个操作，要么全部执行成功，要么全部执行失败。满足原子性的操作，中途不可被中断。

- 可见性

多个线程共同访问共享变量时，某个线程修改了此变量，其他线程能立即看到修改后的值。

- 有序性

程序执行的顺序按照代码的先后顺序执行。（由于JMM模型中允许编译器和处理器为了效率，进行指令重排序的优化。指令重排序在单线程内表现为串行语义，在多线程中会表现为无序。那么多线程并发编程中，就要考虑如何在多线程环境下可以允许部分指令重排，又要保证有序性）

`synchronized`关键字同时保证上述三种特性。

- `synchronized`是同步锁，同步块内的代码相当于同一时刻单线程执行，故不存在原子性和指令重排序的问题
- `synchronized`关键字的语义JMM有两个规定，保证其实现内存可见性：
- 线程解锁前，必须把共享变量的最新值刷新到主内存中；
- 线程加锁前，将清空工作内存中共享变量的值，从主内存中冲洗取值。

`volatile`关键字作用的是保证**可见性**和**有序性**，并不保证原子性。

那么，`volatile`是如何保证**可见性**和**有序性**的？我们先进行基于JMM层面的实现基础，后面两章会进行底层原理的介绍。

## volatile变量的可见性

JMM中规定所有的变量都存储在主内存（Main Memory）中，每条线程都有自己的工作内存（Work Memory），线程的工作内存中保存了该线程所使用的变量的从主内存中拷贝的副本。线程对于变量的读、写都必须在工作内存中进行，而不能直接读、写主内存中的变量。同时，本线程的工作内存的变量也无法被其他线程直接访问，必须通过主内存完成。

![img](2.volatile%E5%8E%9F%E7%90%86.assets/v2-cf02b047fcd7eab8fe4e5e0b59e2e3f0_720w.jpg)

对于普通共享变量，线程A将变量修改后，体现在此线程的工作内存。在尚未同步到主内存时，若线程B使用此变量，从主内存中获取到的是修改前的值，便发生了共享变量值的不一致，也就是出现了**线程的可见性问题**。

`volatile`定义：

- 当对volatile变量执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存
- 写操作会导致其他线程中的缓存无效

这样，其他线程使用缓存时，发现本地工作内存中此变量无效，便从主内存中获取，这样获取到的变量便是最新的值，实现了线程的可见性。

## volatile变量的禁止指令重排序

`volatile`是通过编译器在生成字节码时，在指令序列中添加“**内存屏障**”来禁止指令重排序的。