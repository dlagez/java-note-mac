多个线程同时运行时，线程的调度是由操作系统完成。什么时候运行都是由操作系统决定。

问题：如果多个线程同时读写共享变量，会出现数据不一致的问题。

### 原子操作：

原子操作是指不能被中断的一个或一系列操作。即某一个线程执行时，其他线程必须等待：

```ascii
┌───────┐     ┌───────┐
│Thread1│     │Thread2│
└───┬───┘     └───┬───┘
    │             │
    │-- lock --   │
    │ILOAD (100)  │
    │IADD         │
    │ISTORE (101) │
    │-- unlock -- │
    │             │-- lock --
    │             │ILOAD (101)
    │             │IADD
    │             │ISTORE (102)
    │             │-- unlock --
    ▼             ▼
```

通过加锁的操作，就能保证线程在运行的过程中不会由其他线程进入指令区间，

即使执行期间线程被系统中断，其他线程也会因为无法获得锁导致无法进入此指令区间。

只有执行线程将锁释放后，其他线程才有机会获得锁并执行。加锁和解锁之间的代码我们称之为临界区。

任何时候临界区最多只有一个线程能执行。

### synchronized

synchronized关键字对一个对象进行加锁。

```java
synchronized(lock) {
    n = n + 1;
}
```

synchronized 保证了代码块在任意时刻最多只有一个线程能执行。

synchronized执行原理

```java
synchronized(Counter.lock) { // 获取锁
    ...
} // 释放锁
```

### 例子：

```java
package threadDemo.lxf;

public class synchronized_test {

    public static void main(String[] args) throws InterruptedException {
        AddThread add = new AddThread();
        DecThread dec = new DecThread();
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Counter.count);
    }

    static class Counter {
        public static final Object lock = new Object();
        public static int count = 0;
    }

    static class AddThread extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                synchronized (Counter.lock) {
                    Counter.count += 1;
                }
            }
        }
    }

    static class DecThread extends Thread {
        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                synchronized (Counter.lock) {
                    Counter.count -= 1;
                }
            }
        }
    }
}
```

两个线程都使用Counter.lock作为锁，只有拿到它才能执行，并且这个线程执行期间其他线程因为无法获得锁而不能进入指令区间。

### 总结：

我们来概括一下如何使用`synchronized`：

1. 找出修改共享变量的线程代码块；
2. 选择一个共享实例作为锁；
3. 使用`synchronized(lockObject) { ... }`。

在使用`synchronized`的时候，不必担心抛出异常。因为无论是否有异常，都会在`synchronized`结束处正确释放锁：

### 注意：

如果两个线程之间不会操作同一个变量，那么就不能使用同一个锁，会导致原本可以并发执行的线程，现在无法并发执行了，执行效率会降低。

### 不需要synchronized

已经是原子操作了：

- 基本类型（`long`和`double`除外）赋值，例如：`int n = m`；
- 引用类型赋值，例如：`List<String> list = anotherList`。

`long`和`double`是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把`long`和`double`的赋值作为原子操作实现的。

### 例子：

如果是多行赋值语句，就必须保证是同步操作，例如：

```
class Pair {
    int first;
    int last;
    public void set(int first, int last) {
        synchronized(this) {
            this.first = first;
            this.last = last;
        }
    }
}
```

有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：

```
class Pair {
    int[] pair;
    public void set(int first, int last) {
        int[] ps = new int[] { first, last };
        this.pair = ps;
    }
}
```

就不再需要同步，因为`this.pair = ps`是引用赋值的原子操作。而语句：

```
int[] ps = new int[] { first, last };
```

这里的`ps`是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。