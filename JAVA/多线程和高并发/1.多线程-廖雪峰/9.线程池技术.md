### 复用线程：

```ascii
┌─────┐ execute  ┌──────────────────┐
│Task1│─────────>│ThreadPool        │
├─────┤          │┌───────┐┌───────┐│
│Task2│          ││Thread1││Thread2││
├─────┤          │└───────┘└───────┘│
│Task3│          │┌───────┐┌───────┐│
├─────┤          ││Thread3││Thread4││
│Task4│          │└───────┘└───────┘│
├─────┤          └──────────────────┘
│Task5│
├─────┤
│Task6│
└─────┘
  ...
```

线程池内部维护了若干个线程

没有任务的时候，这些线程都处于等待状态。

如果有新任务，就分配一个空闲线程执行。

如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。

### 使用：

Java标准库提供了`ExecutorService`接口表示线程池，它的典型用法如下：

```
// 创建固定大小的线程池:
ExecutorService executor = Executors.newFixedThreadPool(3);
// 提交任务:
executor.submit(task1);
executor.submit(task2);
executor.submit(task3);
executor.submit(task4);
executor.submit(task5);
```

因为`ExecutorService`只是接口，Java标准库提供的几个常用实现类有：

- FixedThreadPool：线程数固定的线程池；
- CachedThreadPool：线程数根据任务动态调整的线程池；
- SingleThreadExecutor：仅单线程执行的线程池。

创建这些线程池的方法都被封装到`Executors`这个类中

使用：

```java
package threadDemo.lxf;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class demo_Executors {

    public static void main(String[] args) {
        ExecutorService es = Executors.newFixedThreadPool(4);
        for (int i = 0; i < 6; i++) {
            es.submit(new Task("" + i));
        }
        es.shutdown();
    }

}

class Task implements Runnable {

    private final String name;

    Task(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println("start task" + name);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("end task " + name);
    }
}

output：
    
start task2
start task3
start task1
start task0
end task 2
end task 3
start task4
start task5
end task 1
end task 0
end task 4
end task 5
```

创建一个固定大小的线程池：容量为4

可以看出，四个线程执行任务，还有两个任务等待，等线程由时间了再来执行它。

使用`shutdown()`方法关闭线程池的时候，它会等待正在执行的任务先完成

### ScheduledThreadPool

有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用`ScheduledThreadPool`。