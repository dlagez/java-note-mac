### 方法一：

中断一个线程非常简单，只需要在其他线程中对目标线程调用`interrupt()`方法

```java
package threadDemo.lxf;

public class Interrupt_test {

    public static void main(String[] args) throws InterruptedException {
        MyThread t = new MyThread();
        t.start();
        Thread.sleep(1000);
        t.interrupt();
        t.join();
        System.out.println("end!");
    }

    static class MyThread extends Thread {
        @Override
        public void run() {
            int n = 0;
            // 如果线程不是被中断的状态
            while (!isInterrupted()) {
                n++;
                System.out.println(n + " hello!");
            }
        }
    }
}

```

t.interrupt();向t线程发送中断请求，至于t线程是否能结束，要看具体代码。

#### 注意：

如果线程处于等待状态（`t.join()`会让`main`线程进入等待状态），

此时对线程调用interrupt()方法，join()方法会立刻抛出错误InterruptedException，

因此，目标线程只要捕获到`join()`方法抛出的`InterruptedException`，就说明有其他线程对其调用了`interrupt()`方法

下面是代码示例，用来演示上面的结论。

```java
package threadDemo.lxf;

public class Interrupt2_test {

    public static void main(String[] args) throws InterruptedException {
        MyThread t = new MyThread();
        // 启动了t，t会启动hello，并且让hello先运行，此时t处于等待状态
        t.start();
        Thread.sleep(1000); // 主线程休息1秒
        // 这个时候通知t让他中断，可是它现在在处于等待中，等待hello运行，（且hello会一直运行）
        // 会抛出错误，并被捕获，退出线程。
        t.interrupt();
        t.join();
        System.out.println("end!");
    }

    static class MyThread extends Thread {
        @Override
        public void run() {
            HelloThread hello = new HelloThread();
            hello.start();
            try {
                hello.join();  // 等待hello线程结束
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
//            hello.interrupt();
        }
    }

    static class HelloThread extends Thread {
        @Override
        public void run() {
            int n = 0;
            while (!isInterrupted()) {
                n++;
                System.out.println(n+"hello!");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    break;
                }
            }
        }
    }
}
```

### 方法二：

另一个常用的中断线程的方法是设置标志位。我们通常会用一个`running`标志位来标识线程是否应该继续运行，在外部线程中，通过把`HelloThread.running`置为`false`，就可以让线程结束：

```java
package threadDemo.lxf;

public class Interrupt3_test {

    public static void main(String[] args) throws InterruptedException {
        HelloThread t = new HelloThread();
        t.start();
        Thread.sleep(100);
        t.running = false; // 标志位置为false
    }

    static class HelloThread extends Thread {
        public volatile boolean running = true;

        public void run() {
            int n = 0;
            while (running) {
                n++;
                System.out.println(n + " hello!");
            }
            System.out.println("end!");
        }
    }
}
```

### volatile

这里要注意一个问题：volatile关键字

线程之间共享变量用关键子volatile声明。它的作用是

告诉虚拟机：

- 每次访问变量时，总是获取主内存的最新值；
- 每次修改变量后，立刻回写到主内存。

JVM内存模型：

在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！

```bash
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
           Main Memory
│                               │
   ┌───────┐┌───────┐┌───────┐
│  │ var A ││ var B ││ var C │  │
   └───────┘└───────┘└───────┘
│     │ ▲               │ ▲     │
 ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─
      │ │               │ │
┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐
      ▼ │               ▼ │
│  ┌───────┐  │   │  ┌───────┐  │
   │ var A │         │ var C │
│  └───────┘  │   │  └───────┘  │
   Thread 1          Thread 2
└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘
```

这就会导致一个问题，一个线程改变了某个变量，另一个线程读取到的值可能还是更新前的值，

例如，主内存的变量`a = true`，线程1执行`a = false`时，它在此刻仅仅是把变量`a`的副本变成了`false`，主内存的变量`a`还是`true`，在JVM把修改后的`a`回写到主内存之前，其他线程读取到的`a`的值仍然是`true`，这就造成了多线程之间共享的变量不一致。

`volatile`关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。