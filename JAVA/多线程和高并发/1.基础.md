### 进程：

运行的程序，是程序一次执行的过程，或是正在运行的一个程序。

操作系统会为进城分配内存空间。

线程由进程创建的，是进程的一个实体。

一个进程有多个线程。

### 线程：

线程是由进程创建的，是进程的一个实体。

一个进程可以拥有多个线程。

并发和并行

并发：统一时刻，多个任务交替执行，造成一种同时执行的错觉。

并行：统一时刻，多个任务同时进行。多核cpu可以实现并行。

并发和并行可以同时进行。



### 继承Thread类实现多线程

Thread

- 一个类继承了Thread类，该类就可以当成线程使用。
- 我们会重写run方法，写上自己的业务代码
- run Thread 类 实现了Runnabe接口的run方法

```java
public static void main(String[] args) {
    // 创建Cat对象，可以当线程用
    Cat cat = new Cat();
    // 这里为什么是start() 而不是run：因为run就是重写的普通方法，这里直接调用run方法是没有真正的启动一个线程的，相当于还是在main线程里面，把run方法执行完了才会继续往下执行
    cat.start();
    // start() 方法会调用本地的start0方法，有JVM虚拟机来处理
}

class Cat extends Thread {
    @Override
    public void run() {
        
        while(true) {
        	System.out.println("miao miao woshi xiao mao mi");    
        	try{
            	Thread.sleep(1000);    
            } catch (Inter e)
            {
                e.printStackTrace();
            }
            
        }
         
    }
}
```

执行main方法的时候会先创建一个进程，这个进程创建main线程，在main函数中的线程有main线程创建。

主线程结束了，在主线程里面创建的子线程不会结束。

子线程里面也可以创建子线程。都结束了，进程才会退出

### 通过实现Runnable接口来创建多线程

由于java是单继承的，继承了父类之后就不能继承Thread类了，但是我们要实现多线程怎么办，那就是通过实现Runnable接口来实现。

使用了代理模式，将实现了Runnable接口的类放入Thread()里面，调用start() 方法即可



### 线程终止

通知方式：在线程方法里面设置一个boolean值来控制循环的执行。

```java
package exit_;

public class ThreadExit {
    public static void main(String[] args) throws InterruptedException {

        T t1 = new T();
        t1.start();

        System.out.println(" the main Thread sleep 10s ...." );

        Thread.sleep(10 * 1000);

        t1.setLoop(false);
    }
}

class T extends Thread {
    private int count = 0;
    private boolean loop = true;

    @Override
    public void run() {
        while (loop) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("Thread run " + (++count));
        }
    }

    public void setLoop(boolean loop) {
        this.loop = loop;
    }
}
```

### 线程常用方法

- setName // 设置线程名称
- getName  // 返回该线程的名称
- start // 使该线程开始执行
- run 
- setPriority  // 更改线程的优先级
- getPriority  // 获取线程的优先级
- sleep // 休眠
- interrupt // 中断线程 ，作用是中断休眠状态，类似你在睡觉，把你叫醒了继续干活

```java
package methods_;

public class ThreadMethod01 {
    public static void main(String[] args) throws InterruptedException {
        T t1 = new T();
        t1.setName("RocZhang");
        t1.setPriority(Thread.MIN_PRIORITY);
        t1.start();

        for (int i = 0; i < 5; i++) {
            Thread.sleep(1000);
            System.out.println("hi " + i);
        }

        t1.interrupt(); 

    }
}

class T extends Thread {
    @Override
    public void run() {
        while (true) {
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + " eat baozi " + i);
            }

            try {
                System.out.println(Thread.currentThread().getName() + " sleeping ....");
                Thread.sleep(20000);
            } catch (InterruptedException e) {

                System.out.println(Thread.currentThread().getName() + " be interrupted ....");
                ;
            }
        }
    }
}

```

### 线程常用方法第二组：

yield：线程的礼让，让出cpu，让其他线程执行，但礼让时间不确定，所以不一定礼让成功。

join：线程的插队。插队的线程一旦插队，则会先执行完插入的线程的所有任务。

```java
package methods_;

public class ThreadMethod02 {
    public static void main(String[] args) throws InterruptedException {
        int count = 0;
        T2 t2 = new T2();
        t2.start();
        while (count < 20) {
            System.out.println("the main Thread : hi" + count++);
            Thread.sleep(1000);
            if (count == 5) {
                t2.join();
            }
        }

    }

}

class T2 extends Thread {

    private int count;
    @Override
    public void run() {
        while (count < 20){
            System.out.println("the T2 Thread : " + (++count));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

}

```

### 守护线程

d.setDaemon(true);

将子线程设置为守护线程。使得在主线程退出的时候，子线程也会退出。

```java
package methods_;

public class ThreadMethod03 {
    public static void main(String[] args) throws InterruptedException {
        MyDaemonThread d = new MyDaemonThread();
        d.setDaemon(true);
        d.start();
        for (int i = 0; i < 10; i++) {
            System.out.println("wang bao qiang ...");
            Thread.sleep(1000);
        }
    }
}

class MyDaemonThread extends Thread {
    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("ma rong and song jie:");
        }
    }
}

```

### 线程的生命周期

- new
- runnable
- blocked
- waiting
- timed_waiting
- terminated

```java
package methods_;

public class ThreadStatus {
    public static void main(String[] args) throws InterruptedException {
        TS ts = new TS();
        System.out.println(ts.getName() + " status" + ts.getState());
        ts.start();
        while (Thread.State.TERMINATED != ts.getState()) {
            System.out.println(ts.getName() + " status" + ts.getState());
            Thread.sleep(1000);
        }

        System.out.println(ts.getName() + " status" + ts.getState());
    }
}

class TS extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10 ; i ++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("TS run...");
        }
    }
}

/usr/lib/jvm/java-1.11.0-openjdk-amd64/bin/java -javaagent:/snap/intellij-idea-ultimate/311/lib/idea_rt.jar=41909:/snap/intellij-idea-ultimate/311/bin -Dfile.encoding=UTF-8 -classpath /home/roczhang/code/java_demo/out/production/java_demo methods_.ThreadStatus
Thread-0 statusNEW
Thread-0 statusRUNNABLE
Thread-0 statusTIMED_WAITING
TS run...
Thread-0 statusTIMED_WAITING
TS run...
Thread-0 statusTIMED_WAITING
TS run...
Thread-0 statusTIMED_WAITING
TS run...
Thread-0 statusTIMED_WAITING
TS run...
Thread-0 statusTIMED_WAITING
TS run...
Thread-0 statusTIMED_WAITING
TS run...
Thread-0 statusTIMED_WAITING
TS run...
Thread-0 statusTIMED_WAITING
TS run...
Thread-0 statusTIMED_WAITING
TS run...
Thread-0 statusTERMINATED

Process finished with exit code 0

```



Synchronized

线程同步机制

1. 在多线程编程，一些敏感数据不允许被多个线程同时访问。此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。
2. 线程同步，即当有一个线程在对内存进行进行操作时，其他线程都不允许对这个内存地址进行操作。直到该线程完成操作。其他线程才能对该内存地址进行操作。

```java
package syn;

public class SellTicket {

    public static void main(String[] args) {
        SellTicket03 sellTicket03 = new SellTicket03();
        new Thread(sellTicket03).start();
        new Thread(sellTicket03).start();
        new Thread(sellTicket03).start();
    }
}

class SellTicket03 implements Runnable {

    private int ticketNumber = 100;
    private boolean loop = true;

    public synchronized void sell() {
        if (ticketNumber <= 0) {
            System.out.println("sell out...");
            loop = false;
            return;
        }

        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("windows " + Thread.currentThread().getName() + " selled a ticket"
                + " here remain " + (--ticketNumber));
    }

    @Override
    public void run() {
        while (loop) {
            sell();
        }
    }
}
```

### 互斥锁

- java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。
- 每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任何一个时刻。只能有一个线程访问该对象
- 关键字 synchronized 来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任意时刻只能有一个线程访问。
- 同步的局限性：导致程序的执行效率降低
- 同步方法（非静态的）的可以是this，也可以是其他对象（要求是同一个对象）
- 同步方法（静态的）的锁为当前类本身。

注意事项和细节 

- 同步方法如果没有使用static修饰：默认锁对象为this
- 如果方法使用static修饰，默认锁对象：当前类.class
- 实现锁步骤：需要先分析上锁的代码，选择同步代码块或同步方法，要求多个线程的锁对象为同一个即可。

静态的方法不好理解，这里解释下：如果使用静态方法实现同步代码块。需要将类本身作为锁对象.

意思就是给类上锁。

```java
public static void m2() {
    synchronized (SellTicket03.class) {
        System.out.println("m2");
    }
}
```

### 死锁

多个线程都占用了对方的锁资源，但不肯相让，导致了死锁。

### 释放锁

- 当前线程的同步方法、同步代码块执行结束。

  案例：上厕所，完事出来。

- 当前线程在同步代码块、同步方法中遇到break、return

  案例：上厕所没有正常完事、经理叫他修改bug，不得不出来。

- 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception导致异常结束。

  案例：上厕所没有正常完事，发现忘记带纸，不得不出来

- 当前线程在同步代码块，同步方法中执行了线程对象的wait() 方法，当前线程暂停，并释放锁。

  案例: 上厕所没有正常完事，觉得需要酝酿下，所以出来等会再进去。

### 释放锁分析

- 线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁。

  案例：上厕所，太困了，在坑位上眯了一会。

- 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起。该线程不会释放锁。

  