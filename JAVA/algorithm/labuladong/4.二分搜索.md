### 二分查找框架

```java
int binarySearch(int[] nums, int target) {
		int left = 0, right = ...;
		while (...) {
      if (nums[mid] == target) {
        ...
      } else if (nums[mid] < target) {
        left = ...;
      } else if (nums[mid] > target) {
        right = ...
      }  
    }
		return ...;
}
```

### 思考：

我在看一些源码的时候发现，比如HashMap的源码很少使用*和/两个算数操作符号，更多的是使用左移和右移操作符实现。后来百度发现计算机底层对位的操作是最快的。我以后写代码能不能都使用位操作符？

比如HashMap在扩容时是使用

```java
else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
         oldCap >= DEFAULT_INITIAL_CAPACITY)
    newThr = oldThr << 1; // double threshold
```

左移操作符号，oldThr的二进制左移一位就是相当于oldThr*2的操作。扩容两倍。

### 寻找一个数（基本的二分搜索）

```java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = left + (right - left) << 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}

```

### 实验：

计算mid的时候我使用的是右移位操作，发现第一遍循环的时候mid计算的是对的

![image-20210917213110815](4.%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2.assets/image-20210917213110815.png)

第二遍循环的时候：mid = 5 + 3/2 = 6， 但是它的结果是mid=4，和上一次循环的数值一样，没有变化。

![image-20210917213143922](4.%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2.assets/image-20210917213143922.png)

很奇怪。实验失败，暂时没找到答案，还是老老实实的用除号吧。

### 思考：为什么while循环中的条件是<=而不是<?

前面定义了right，说明我们的数组是这样的：[left, right]

左右边界都包含进去了。这个时候我们使用<符号作为结束条件时。

有这样一种情况：数组里面只有一个数了 [8，8]，此时的left=right，丢进while循环时，他会判定循环结束了。此时的这个数字8我们就没有比较过，数字8就漏掉了。

如果我们要找的书就是8，函数就错了直接返回-1。

```
int right = nums.length - 1
```

参考文献：

- https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-4/er-fen-cha-zhao-xiang-jie
