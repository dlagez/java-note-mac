### 合并两个有序链表

思路：就是通过while循环每次比较p1和p2的大小，把较小的节点接到结果链表上。

这里有个虚拟头节点。目的是为了降低代码复杂度。可以避免处理空指针的情况。

```java
ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    // 虚拟头结点
    ListNode dummy = new ListNode(-1), p = dummy;
    ListNode p1 = l1, p2 = l2;

    while (p1 != null && p2 != null) {
        // 比较 p1 和 p2 两个指针
        // 将值较小的的节点接到 p 指针
        if (p1.val > p2.val) {
            p.next = p2;
            p2 = p2.next;
        } else {
            p.next = p1;
            p1 = p1.next;
        }
        // p 指针不断前进
        p = p.next;
    }

    if (p1 != null) {
        p.next = p1;
    }

    if (p2 != null) {
        p.next = p2;
    }

    return dummy.next;
}
```

### 单链表的倒数第 k 个节点

首先，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

<img src="3.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AD%E4%B8%AA%E5%A5%97%E8%B7%AF.assets/image-20210902202644229.png" alt="image-20210902202644229" style="zoom: 33%;" />

现在的 `p1`，只要再走 `n - k` 步，就能走到链表末尾的空指针了对吧？

<img src="3.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AD%E4%B8%AA%E5%A5%97%E8%B7%AF.assets/image-20210902202722692.png" alt="image-20210902202722692" style="zoom: 33%;" />

趁这个时候，再用一个指针 `p2` 指向链表头节点 `head`，让 `p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时走了 `n - k` 步，`p2` 也走了 `n - k` 步，也就是链表的倒数第 `k` 个节点：

<img src="3.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AD%E4%B8%AA%E5%A5%97%E8%B7%AF.assets/image-20210902202744311.png" alt="image-20210902202744311" style="zoom: 33%;" />

注意一下：[1,2,3,4,5]的倒数第二个节点是4，因为最后一个指针是null。而他们相隔k个指针。

```java
// 返回链表的倒数第 k 个节点
ListNode findFromEnd(ListNode head, int k) {
    ListNode p1 = head;
    // p1 先走 k 步
    for (int i = 0; i < k; i++) {
        p1 = p1.next;
    }
    ListNode p2 = head;
    // p1 和 p2 同时走 n - k 步
    while (p1 != null) {
        p2 = p2.next;
        p1 = p1.next;
    }
    // 此时的 p1 已经走到了空指针处。
    // p2 现在指向第 n - k 个节点
    return p2;
}
```

实例：删除倒数第n个指针：

思路：能找到第n个指针的前一个指针就好了，直接就可以删除第n个节点了。这里也要用到虚拟头节点。

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        // 找到倒数第n+1个数
        ListNode x = findFromEnd(dummy, n+1);
        // 将第n个数删除
        x.next = x.next.next;
        return dummy.next;
    }

    public ListNode findFromEnd(ListNode head, int n){
        ListNode p1 = head;
            // p1先走n步
            for (int i = 0; i< n; i++) {
                p1 = p1.next;
            }
            ListNode p2 = head;
            // p1和head一起走
            while(p1 != null) {
                p1 = p1.next;
                p2 = p2.next;
            }

            return p2;
    };
}
```

### 单链表的中点

思路：一快一慢的指针，快指针的速度是慢指针两倍。

```java
ListNode middleNode(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
    }
    // 慢指针指向中点
    return slow;
}
```

### 判断链表是否包含环

使用快慢指针：每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。

如果 `fast` 最终遇到空指针，说明链表中没有环；如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。

```java
boolean hasCycle(ListNode head) {
  ListNode slow = head, fast = head;
  while (fast != null && fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
    if (slow == fast) {
      return true;
    }
  }
  return false;
}
```

### 两个链表是否相交

```
ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		ListNode p1 = headA, p2 = headB;
		while(p1 != p2) {
		if (p1 == null) p1 = headB;
		else p1 = p1.next;
		if (p2 == null) p2 = headA;
		else p2 = p2.next;
		}
		return p1;
}


```

