### 类加载子系统的作用

类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。

classloader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。

加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量



![image-20210815172556750](1.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.assets/image-20210815172556750.png)

### 类加载过程

![image-20210815173518111](1.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.assets/image-20210815173518111.png)

#### 加载：

1. 通过一个类的全限定类名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

![image-20210815173316056](1.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.assets/image-20210815173316056.png)

#### 链接：

![image-20210815173610725](1.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.assets/image-20210815173610725.png)

#### 初始化：

clinit 是所有类（静态）变量的赋值动作和静态代码块中的语句合并而来。

![image-20210815175124328](1.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.assets/image-20210815175124328.png)

主要多个线程使用一个类，这个类只会被初始化（加载）一次。所以定义类的时候要注意，如果类的加载除了问题，会导致其他的线程进入阻塞的状态。 

```java
public class ClassInitTest{
    private static int num = 1;
    static {
        num = 2;
        number = 20;
    }
    private static int number = 10;
    
    public static void main(String[] args) {
        System.out.println(ClassInitTest.num); //2
    }
}
```

number声明在static的下面，赋值在static里面 。这个操作是可以的

这个静态代码块不会报错，因为在类加载过程中有一个链接的过程，链接的第二步准备过程会为变量分配内存，并设置该类变量的默认值。此时变量已经赋值为0了，已经被加载到内存里面了，此时初始化的时候会对这个值进行重新的覆盖。现在static代码块里面赋值20，然后再赋值为10。

ps：在static代码块里面可以为number赋值，但是不能调用他，因为他没有被声明。报错：非法的前向引用。

