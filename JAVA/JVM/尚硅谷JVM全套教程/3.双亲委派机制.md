java虚拟机对class文件采用按需加载的方式，加载class文件时java虚拟机采用的是双亲委派机制。

即把请求交由父类处理。

## 工作原理

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父亲的加载器去执行。
2. 如果父亲加载器还存在父亲加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器。
3. 如果父类加载器可以完成类加载任务，就返回成功，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制。

实例：我们新建一个java.lang.String()类，然后运行下面的代码：

```
package JVM;

public class BootstrapClassLoaderTest {
    public static void main(String[] args) {
        String s = new java.lang.String();
        System.out.println("hello, ");
        
         BootstrapClassLoaderTest test = new BootstrapClassLoaderTest();
        System.out.println(test.getClass().getClassLoader());
    }
}

output:
hello, 
jdk.internal.loader.ClassLoaders$AppClassLoader@3d4eac69
```

1.发现创建的s不是我们自己定义的类。是因为双亲委派机制，创建类会一直委派到启动类加载器，它发现java.lang.String() 类自己可以创建，所以就直接创建了。

2.创建自己类的对象

- 本类对象归Application类加载器管，但是会直接向上委托到引导类加载器。

- 会向上委托到引导类加载器，引导类加载器，引导类加载发现这个类所在的包我不管，这时它就会向下继续委托。
- 到了拓展类加载器（Extension ClassLoader) 拓展类加载器发现这个类所在的包我也不管，这时它就会向下继续委托。
- 这个时候到了系统类加载器，此时完成类的加载。

![image-20210816010411220](3.%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.assets/image-20210816010411220.png)

## 实例

加载jdbc.jar

![image-20210816011705834](3.%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.assets/image-20210816011705834.png)

引导类加载器和拓展类加载器都加载不料jdbc.jar，所以会向下委托到系统类加载器。

## 优势

- 避免了类的重复加载 	
- 保护程序安全，防止核心API被随意篡改。



看到了37

