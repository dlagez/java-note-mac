JVM的启动是通过 引导类加载器 （bootstrap class loader）创建一个初始类完成的。

JVM组成结构之一就是类装载器子系统

## Java代码执行流程图

其中要经历`类加载器`这个流程

![image-20210815154445722](%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B.assets/image-20210815154445722.png)

### 类加载系统架构图

![image-20210815154542988](%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B.assets/image-20210815154542988.png)

### 类的生命周期

类的生命周期包括：加载、链接、初始化、使用和卸载，其中`加载`、`链接`、`初始化`，属于`类加载的过程`

### 类加载的过程

![image-20210815154636129](%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B.assets/image-20210815154636129.png)

#### 第一步：Loading加载

通过类的全限定名称（包名+类名），获取到该类的.class文件的二进制字节流

将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构

在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

总结：`加载二进制数据到内存` —> `映射成jvm能识别的结构` —> `在内存中生成class文件`。

#### 第二步：Linking链接

链接时指将上面创建好的class类合并至Java虚拟机中，使之能够执行的过程，可分为验证、准备、解析三个阶段

1. 验证（Verify）

   确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class的正确性，不会危害到虚拟机的安全。

2. 准备（Prepare）
   为类中的静态字段分配内存，并设置默认的初始值，比如int类型的初始值是0，被final修饰的static字段不会设置，因为final在编译的时候就分配了

3. 解析（Resolve）
   解析阶段的目的，是将常量池内的符号引用转换为直接引用的过程。

   如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

   解析动作主要针对类、接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。

#### 第三步：initialization初始化

初始化就是执行类的构造器方法`init`()的过程。

这个方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。

### 类加载器的分类

![image-20210815160050393](%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B.assets/image-20210815160050393.png)

- **第一个：启动类/引导类：Bootstrap ClassLoader**

> 这个类加载器使用C/C++语言实现的，嵌套在JVM内部，java程序无法直接操作这个类。
>
> 它用来加载Java核心类库，如：`JAVA_HOME/jre/lib/rt.jar`、`resources.jar`、`sun.boot.class.path`路径下的包，用于提供jvm运行所需的包。
>
> 并不是继承自java.lang.ClassLoader，它没有父类加载器
>
> 它加载`扩展类加载器`和`应用程序类加载器`，并成为他们的父类加载器
>
> 出于安全考虑，启动类只加载包名为：java、javax、sun开头的类

- **第二个：扩展类加载器：Extension ClassLoader**

> Java语言编写，由
>
> ```
> sun.misc.Launcher$ExtClassLoader
> ```
>
> 实现，我们可以用Java程序操作这个加载器
>
> 派生继承自java.lang.ClassLoader，父类加载器为`启动类加载器`
>
> 从系统属性：`java.ext.dirs`目录中加载类库，或者从JDK安装目录：`jre/lib/ext`目录下加载类库。我们就可以将我们自己的包放在以上目录下，就会自动加载进来了。

- **第三个：应用程序类加载器：Application Classloader**

> Java语言编写，由
>
> ```
> sun.misc.Launcher$AppClassLoader
> ```
>
> 实现。
>
> 派生继承自java.lang.ClassLoader，父类加载器为`启动类加载器`
>
> 它负责加载`环境变量classpath`或者`系统属性java.class.path`指定路径下的类库
>
> 它是程序中默认的类加载器，我们Java程序中的类，都是由它加载完成的。
>
> 我们可以通过`ClassLoader#getSystemClassLoader()`获取并操作这个加载器

- **第四个：自定义加载器**

> 一般情况下，以上3种加载器能满足我们日常的开发工作，不满足时，我们还可以自定义加载器
>
> 比如用网络加载Java类，为了保证传输中的安全性，采用了加密操作，那么以上3种加载器就无法加载这个类，这时候就需要`自定义加载器`

**自定义加载器实现步骤**

> 继承
>
> ```
> java.lang.ClassLoader
> ```
>
> 类，重写findClass()方法
>
> 如果没有太复杂的需求，可以直接继承`URLClassLoader`类，重写`loadClass`方法，具体可参考`AppClassLoader`和`ExtClassLoader`。

**获取ClassLoader几种方式**

它是一个抽象类，其后所有的类加载器继承自 ClassLoader（不包括启动类加载器）

```java
// 方式一：获取当前类的 ClassLoader
clazz.getClassLoader()
// 方式二：获取当前线程上下文的 ClassLoader
Thread.currentThread().getContextClassLoader()
// 方式三：获取系统的 ClassLoader
ClassLoader.getSystemClassLoader()
// 方式四：获取调用者的 ClassLoader
DriverManager.getCallerClassLoader()
```