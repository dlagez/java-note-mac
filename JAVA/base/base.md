### static

用于内存管理，用来共享给定类的相同变量或方法，可以使用static修饰variables, methods, blocks, and nested classes。

静态关键字属于类，而不是类的实例。静态关键字用于一个常量变量或类的每个实例都相同的方法。

当一个类的成员使用static关键字修饰，不需要定义任何对象即可使用该成员。

```java
// Java program to demonstrate that a static member
// can be accessed before instantiating a class

class Test
{
	// static method
	static void m1()
	{
		System.out.println("from m1");
	}

	public static void main(String[] args)
	{
		// calling m1 without creating
		// any object of class Test
		m1();
	}
}
```



### 基础的数据类型：

- 4 种整数型：`byte`、`short`、`int`、`long`
- 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`

这 8 种基本数据类型的默认值以及所占空间的大小如下：

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |
| --------- | ---- | ---- | ------- | ------------------------------------------ |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 |
| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |
| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
| `boolean` | 1    |      | false   | true、false                                |



#### 基本数据类型的转换：

当java程序在进行赋值，精度小的类型自动转换为精度大的数据类型。

char -> int -> long -> float -> double

byte -> short -> int -> long -> float -> double

为什么这里有两条线，因为（byte、short）和char之间不会相互自动转换， 他们三者之间可以计算，在计算时首先转换为int类型。boolean类型不会参与类型的自动转换。

```java
int num  = 'a' // ok char -> int
```

细节：

如果多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。

```java
int n1 = 10;
float d1 = n1 + 1.1; // 错误，因为1.1是double类型
```



```java
byte b1 = 10;
int n2 = 1;
byte b2 = n2;  // 错误，使用变量赋值，是判断类型。因为n2为int类型，所以在内存中使用了4个字节的存储空间来存储。而byte只是使用了一个字节的存储空间。	
char c1 = b1; // 错误，byte不能自动转换成char。
```

他们三者之间可以计算，在计算时首先转换为int类型。 注意byte+byte也会被转换成int

```java
byte b2 = 1;
byte b3 = 2;
short s1 = 1;
short s2 = b2 + s1; // 错误，b2 + s1 =》 int

byte b4 = b2 + b3; // 错误，b2+b3运算过后会变成int类型
```

#### 强制类型转换：

```java
int n1 = (int)1.9;
sout(n1) : 1  精度损失
  
int n2 = 2000;
byte b1 = (byte)n2;
sout(b1) : -48  数据溢出
```

 

```java
short s = 12;
s = s - 9; // 错误，s-9结果为int

byte b = 10;
b = b + 11; // 错误 结果为int
b = (byte)(b + 11); // 正确，使用了类型强转

char c = 'a';
int i = 16;
float d = .314F;
double result = c + i + d; // 结果为float，可以使用精度更大的double

byte b = 16;
shorts = 14;
short t = s + b;  // 错误，因为byte和short混合运算会变成int类型。
```



基本数据类型和String类型的转换

```java
int n1 = 100
String s1 = n1 + "";
```



将String类型转成基本数据类型

```java
String s1 = "123";
int n1 = Integer.parseInt(s1);
```



### 位运算

```
int a = 1 >> 2; 1 向右位移两位。

~2 = ? // 按位取反
2&3 = ？ // 2按位与2
-3^3 // 按位异或
```

#### 原码、反码、补码

- 正数的原码、反码、补码都一样
- 负数的反码=它的原码符号位不变，其他位取反
- 负数的补码=它的反码+1，负数的反码=负数的补码-1
- 0的反码，补码都是0
- java没有无符号数，换言之，java中的数都是有符号的
- 在计算机运算的时候，都是以补码的方式来运算的
- 当我们要看运算结果的时候，要看它的原码

#### 位运算符

（&、｜、^、~、>>、<<和>>>）

分别是按位与&、按位或｜、按位异或^、按位取反~，

1. 按位与$：两位全为1，结果为1，否则为0
2. 按位或｜：两位有一个为1，结果为1，否则为0
3. 按位异或^：两位一个为0一个为1，结果为1， 否则为0。
4. 按位取反~：0->1， 1->0



```java
2 & 3 = 
```

计算过程
先得到2的补码 => 2的原码 00000000 00000000 00000000 00000010
2的补码 => 2的补码 00000000 00000000 00000000 00000010

3的原码 => 3的原码 00000000 00000000 00000000 00000011
3的补码 => 3的补码 00000000 00000000 00000000 00000011

运算，按位与
00000000 00000000 00000000 00000010
00000000 00000000 00000000 00000011
00000000 00000000 00000000 00000010 这个是运算后的结果，为补码形式，符号位为0，所以它的原码和它相同
运算后的结果：00000000 00000000 00000000 00000010
转成10进制：2



```java
~-2
```

-2的原码：10000000 00000000 00000000 00000010

-2的反码：11111111 11111111 11111111 11111101

-2的补码：11111111 11111111 11111111 11111110 等于反码加1

~-2操作：00000000 00000000 00000000 00000001 运算后的补码

运算后的原码：1



```java
~2
```

得到2的补码：00000000 00000000 00000000 00000010

~2操作：11111111 11111111 11111111 11111101 运算后的补码

（补码-1得到反码，然后符号位不变其他位取反得到原码）

运算后的反码：11111111 11111111 11111111 11111100

运算后的原码：100000000 00000000 00000000 00000011 => -3



1. 算数右移>> :                低位溢出，符号位不变，并用符号位补溢出的高位
2. 算数左移<<：符号位不变，低位补0
3. `>>>`逻辑右移，也叫无符号右移，运算规则是：低位溢出，高位补0
4. 没有`<<<`符号。

例子：

```java
int a = 1 >> 2; 00000001 => 00000000 本质1/2/2=0
int a = 1 << 2; 00000001 => 00000100 本质1*2*2=4
```

小数参与运算结果是近似值。



```java
int i = 66;
sout(++i+i) // i = i + 1 => i = 67 => 134
```



```java
int num1 = (int)"18"; // 错误 Integer.paeseInt();
int num2 = 18.0; // 错误，18.0是double类型
double num3 = 3d; // ok 3d表示3为double类型
double num4 = 8； // ok 自动类型转换
int i = 48; char ch = i + 1; // int不能转换成char
byte b = 19; short s = b + 2；// b+2的结果是int
```



### 数组

细节：一个数组里面必须是相同类型的数据，但是定义的时候我们可以这样定义， int类型会自动类型转换成double类型。

```java
double[] arr = {1.1, 2.2, 100} 
```



数组创建的时候，如果没有赋值，数组是有默认值的。数组属于引用类型，数组型数据是对象。

- int : 0
- short : 0
- byte : 0
- long : 0
- float : 0
- double : 0
- char : \u0000
- boolean : false
- String : null

示例：

```
char[] chars = new char[26];
for (int i = 0; i < chars.length; i++) {
	chars[i] = (char)('A' + i);
}
```



#### 数组赋值机制

```java
int n1 = 10;
int n2 = n1;

n2 = 80;
sout(n1); // 10
sout(n2); // 80

int[] arr1 = {1, 2, 3};
int[] arr2 = arr1; // 把arr1赋值给arr2，改变arr2会影响arr1的值。
```



- 基本数据类型赋值，赋值方式为值拷贝。
- 数组在默认情况下是引用传递，赋的值是地址。



基本数据类型在栈中，引用数据类型在堆中。

![image-20220228201424294](https://cdn.jsdelivr.net/gh/dlagez/img@master/image-20220228201424294.png)

#### 数组的拷贝

```java
int[] arr1 = {10, 20, 30};
int[] arr2 = new int[arr1.length];
// 遍历赋值即可
for (int i = 0; i < arr1.length; i++) {
		arr2[i] = arr1[i];
}
```



### 方法的传参机制

基本数据类型是值传递，对象是地址传递。比如数组。

这里需要注意：test方法中虽然将p的地址传递进去了，但是p=null操作会将方法中的p指向null，就不会指向main方法中的person了。所以输出的年龄还是10。

```java
Person p = new Person();
p.name = "jack";
B b = new B();
b.test(p);
sout(p.age) // 10

class B {
	public void test(Person p) {
		p = null;
	}
}
```

#### 对象的拷贝

这个方法在堆中创建了一个新的person对象，并将传进来的对象的属性赋值到这个对象中。

```java
public Person copyPerson(Person p) {
	Person p2 = new Person();
	p2.name = p.name;
	p2.age = p.age;
	return p2;
}
```



### 递归

