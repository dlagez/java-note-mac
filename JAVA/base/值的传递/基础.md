除了基本类型之外的，所有类型，包括数组的赋值，都是引用传递

### 一：搞清楚 基本类型 和 引用类型的不同之处

```text
int num = 10;
String str = "hello";
```

<img src="https://pic1.zhimg.com/80/166032bc90958c21604110441ad03f45_720w.jpg?source=1940ef5c" alt="img" style="zoom:50%;" />

num是基本类型，值直接保存在变量中

str是引用类型，变量中保存的只是实际对象的地址。一般这种这个变量称为“引用”。引用指向实际对象，实际对象中保存着内容。

### 二：搞清楚赋值运算符（=）的作用

```text
num = 20;
str = "java";
```

<img src="https://pic3.zhimg.com/80/287c0efbb179638cf4cf27cbfdf3e746_720w.jpg?source=1940ef5c" alt="img" style="zoom:50%;" />

对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。
对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。**但是原来的对象不会被改变（重要）。**
如上图所示，"hello" 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）

作者：Intopass
链接：https://www.zhihu.com/question/31203609/answer/50992895
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



三：调用方法时发生了什么？**参数传递基本上就是赋值操作**。

```text
第一个例子：基本类型
void foo(int value) {
    value = 100;
}
foo(num); // num 没有被改变
// 这里应该是值的拷贝，将number的值拷贝到了value上

第二个例子：没有提供改变自身方法的引用类型
void foo(String text) {
    text = "windows";
}
foo(str); // str 也没有被改变
// 这里的str地址拷贝到了text变量上面，但是方法里面将“windows”的地址赋值到了text，覆盖了str的地址，这里str的地址值并没有改变，只是没有了引用。

第三个例子：提供了改变自身方法的引用类型
StringBuilder sb = new StringBuilder("iphone");
void foo(StringBuilder builder) {
    builder.append("4");
}
foo(sb); // sb 被改变了，变成了"iphone4"。

第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。
StringBuilder sb = new StringBuilder("iphone");
void foo(StringBuilder builder) {
    builder = new StringBuilder("ipad");
}
foo(sb); // sb 没有被改变，还是 "iphone"。
```