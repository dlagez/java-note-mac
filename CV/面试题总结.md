## java基础

### 基础的数据类型：

- 4 种整数型：`byte`、`short`、`int`、`long`
- 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`



hashmap

参考：[link](https://tech.meituan.com/2016/06/24/java-hashmap.html)



线程池技术：[link](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)

## **计网**

### TCP UDP

**知道TCP吗？介绍一下TCP，包括三次握手的原理和意义？**



**传输层有两个主要的协议，tcp和udp，tcp提供可靠的通信传输。**

注：udp常用于广播。

意义：为了能把数据准确可靠的传输给对方

原理：

发送端先发送一个带有syn的数据包给接受端，表示发送端的发送数据功能没有问题。

接收端接收到了数据之后呢发送一个带有syn/ack的数据包给发送端，表示接收端的接收数据和发送数据功能没有问题。

发送端接收到了数据之后呢，再次发送一个带有ack标志的数据包给接收端，表示发送端的接收数据功能没有问题。



**四次挥手？**



**UDP呢？它和TCP的区别？**

udp是一种面向无连接的传输协议，它只负责发送数据，接收放接收到数据它不关系。适用于保证实时性的应用：ip电话、视频会议等。



**TCP的拥塞控制和流量控制是怎么样的？**

流量控制：发送端发送数据的时候会根据自己的网络情况发送数据，它并不知道接受端的情况，如果发送端的情况很好，发送的数据量很大，而此时接受端的情况不好，处于高负荷状态，这种情况下会导致接受端不能及时接收发送端发送过来的数据，就会导致数据的丢失，数据丢失之后就会触发重发机制，导致网络流量的浪费。为了避免这种情况，就设计出了流量控制机制。

TCP提供一种机制可以让发送端根据接受端的实际接收数据能力控制发送的数据量。这就是流量控制。

他的具体操作是接受端主动向发送端通知自己可以接收数据的大小。于是发送端就会发送不超过这个限度的数据。这个大小限度就被称为窗口大小。



**TCP怎么保证可靠性？** ref：图解TCP/UDP

- 通过序列号与确认应答提高可靠性
- 超时重发控制
- 滑动窗口控制
- 连接管理
- 流量控制
- 拥塞控制



## java基础

### 序列化

序列化是指把一个Java对象变成二进制内容，本质上就是一个`byte[]`数组。

一个Java对象要能序列化，必须实现一个特殊的`java.io.Serializable`接口。

```java
public class demo8_serializable {
    public static void main(String[] args) throws IOException {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        try (ObjectOutputStream output = new ObjectOutputStream(buffer)) {
            output.writeInt(12345);
            output.writeUTF("Hello");
            output.writeObject(Double.valueOf(123.456));
        }
        System.out.println(Arrays.toString(buffer.toByteArray()));
    }
}
```

序列化可以写入基本类型int、boolean、String，还可以写入实现了Serialozable的Object。

```
[-84, -19, 0, 5, 119, 11, 0, 0, 48, 57, 0, 5, 72, 101, 108, 108, 111, 115, 114, 0, 16, 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 68, 111, 117, 98, 108, 101, -128, -77, -62, 74, 41, 107, -5, 4, 2, 0, 1, 68, 0, 5, 118, 97, 108, 117, 101, 120, 114, 0, 16, 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 78, 117, 109, 98, 101, 114, -122, -84, -107, 29, 11, -108, -32, -117, 2, 0, 0, 120, 112, 64, 94, -35, 47, 26, -97, -66, 119]
```

反序列化：

为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的`serialVersionUID`静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变`serialVersionUID`的值，这样就能自动阻止不匹配的class版本：

要特别注意反序列化的几个重要特点：

反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。



## 操作系统

进程与线程的区别 ref：[link](https://cloud.tencent.com/developer/article/1688297)

进程是对运行时程序的封装，系统进行资源调度和分配的基本单位，实现了操作系统的并发。

线程是进程的子任务，是CPU调度和分派的基本单位。

区别：

 **一个线程只能属于一个进程，而一个进程可以有多个线程**，但至少有一个线程。线程依赖于进程而存在。

**进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存**。

**进程是资源分配的最小单位，线程是CPU调度的最小单位**；

**线程间可以直接读写进程数据段（如全局变量）来进行通信**

**进程间通信IPC**

**进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂**。

**进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉**



进程的通信方式：还没看，不想直接copy，所以留着后面补上。