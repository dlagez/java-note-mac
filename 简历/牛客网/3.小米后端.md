### 线程安全

产生线程不安全的原因
多个线程对同一个资源同时进行写操作。比如同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。

Java中实现线程安全的方法
在Java多线程编程当中，提供了多种实现Java线程安全的方式：

最简单的方式，使用Synchronization关键字:Java Synchronization介绍
使用java.util.concurrent.atomic 包中的原子类，例如 AtomicInteger
使用java.util.concurrent.locks 包中的锁
使用线程安全的集合ConcurrentHashMap
使用volatile关键字，保证变量可见性（直接从内存读，而不是从线程cache读）

### 锁

### Synchronized（同步锁）

可以对动态方法修饰

```
public synchronized void doSomething(){}
```

####  对代码块的修饰。

public  void  increaseAmt(float increaseAmt){
		
```java
	try {
		TimeUnit.SECONDS.sleep(1);
	} catch (InterruptedException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	synchronized (this) {
		System.out.println(this);
		amt+=increaseAmt;
	}
}
```

### Lock

Lock对比synchronized有高手总结的差异如下：

总结来说，Lock和synchronized有以下几点不同：

　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；

　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；

　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；

　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。

　　5）Lock可以提高多个线程进行读操作的效率。

#### 堆和栈的区别有哪些？

1、栈由系统自动分配，而堆是人为申请开辟；

2、栈获得的空间较小，而堆获得的空间较大；

3、栈由系统自动分配，速度较快，而堆一般速度比较慢；

4、栈是连续的空间，而堆是不连续的空间。

栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量

堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象）

比如主函数的语句 int[] arr = new int[3]; 在内存中是怎么定义的。

1. 主函数进栈，在栈中定义一个变量arr
2. 在对中通过new关键字开辟一个空间，这个空间用来创建一个对象。也就是创建的数组。
3. 然给这个块空间分配一个内存地址。
4. 把堆中的地址赋值给arr，arr就通过这个地址指向了数组。

1.栈内存存储的是局部变量而堆内存存储的是实体；

2.栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；

3.栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。



线程中断：

使用的方法：使用的是interrupt()方法中断线程。

中断的原理：java中断机制是一种协作机制，也就是说中断操作并不能直接终止另外一个线程，而需要被中断的线程自己处理中断。

每个线程对象里面都有一个boolean类型的表识，代表着是否有中断请求（该请求可以来自所有线程，包括被中断的线程本身）。例如，当线程 t1 想中断线程 t2，只需要在线程 t1 中将线程 t2 对象的中断标识置为 true，然后线程 t2 可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。

### Linux 进程的睡眠和唤醒
