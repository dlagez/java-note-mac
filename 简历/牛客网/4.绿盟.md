### 输入一个url请求到页面展示经历了哪些过程

面试的时候被问到这个问题好几次，总的来说查阅资料显示，总体被分为这样几个过程

1、DNS解析

2、TCP连接

3、发送HTTP请求

4、服务器处理请求并且返回HTTP报文

5、浏览器解析并且渲染页面

6、连接结束

具体的步骤有：

1、DNS解析

将浏览器输入的地址转换为唯一的ip地址

2、TCP连接

HTTP协议是以TCP协议作为传输层协议的

3、HTTP请求

其实这部分又可以称为前端工程师眼中的 HTTP，它主要发生在客户端，发送HTTP请求的过程就是构建HTTP请求报文并通 过TCP协议中发送到服务器指定端口。HTTP请求报文是由三部分组成：请求行，请求报头和请求正文

常见的问题有：

GET和POST请求有什么区别

HTTP状态码

301和302有什么区别

4、服务器处理HTTP请求并且返回报文

响应报头、响应报文

5、浏览器渲染解析页面

浏览器是一个边解析边渲染的过程，首先浏览器解析HTML文件构成DOM树，然后解析CSS文件构建渲染树，等到渲染完成 后，浏览器开始布局渲染树并将其绘制到屏幕上，这个过程比较复杂，涉及到两个概念，reflow（回流）和 repain（重 绘）。DOM节点各个元素都是以盒模型的形式存在，这些都是需要浏览器去计算其位置和大小等，这个过程被称作为 reflow，当浏览器的DOM属性确定下来之后，浏览器便开始绘制内容，这个过程被称为repain。页面在首次加载必然会经历 reflow和repain，非常的消耗性能，而移动端的设备资源有限，有时候会造成页面卡顿，应当尽量减少。

JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都 需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先 执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程 加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步 任 务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行 栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。

## 数据库设计三大范式

1. **第一范式(确保每列保持原子性)**：所有字段值都是不可分解的原子值
2. **第二范式**：所有非主属性都必须完全依赖于主键，主键可能由多个属性构成，完全依赖要求不允许存在非主属性依赖于主键中的某一部分属性。
3. **第三范式**：每列都与主键有直接关系，不存在传递依赖

## 数据库主键如何设计

- 主键能唯一的标识表中的每一行。这样的一列或者多列称为表的主键。
- 确保主键的无意义性
- 采用整型主键

## HashMap的实现原理

当程序执行 map.put(String,Obect)方法 时，系统将调用String的 hashCode() 方法得到其 hashCode 值——每个 Java 对象都有 hashCode() 方法

都可通过该方法获得它的 hashCode 值。得到这个对象的 hashCode 值之后，系统会根据该 hashCode 值来决定该元素的存储位置

### hash冲突解决：

链地址法：将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。

多线程并发问题：

大多数javaer都知道HashMap是线程不安全的，多线程环境下数据可能会发生错乱，一定要谨慎使用。这个结论是没错，可是HashMap的线程不安全远远不是数据脏读这么简单，它还有可能会发生**死锁，造成内存飙升100%的问题**

假如我们有两个线程Thread1和Thread2,假如在遍历的过程中，Thread1此时在链表的节点上e1，next指针会下一层指向e2;而此时Thread2遍历在e2节点上，它往回遍历next指针指向e1，那么此时的链表结构就被破坏了，形成了双向指针，构成了一个闭环（如图所示），就造成“死锁了”，我们来复习一下造成死锁的4个条件。

**死锁的四个条件**

1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

解决方法：

使用ConcurrentHashMap，它是线程安全的，

## 为什么需要把HashMap的链表设计为红黑树

hashmap的链表一开始并不是红黑树。**当链表长度大于或等于阈值（默认为 8）的时候，如果同时还满足容量大于或等于 MIN_TREEIFY_CAPACITY（默认为 64）的要求，就会把链表转换为红黑树。**

**同样，后续如果由于删除或者其他原因调整了大小，当红黑树的节点小于或等于 6 个以后，又会恢复为链表形态。**

## **hashmap结构**

JDK 1.8 的 HashMap 和 ConcurrentHashMap 都有这样一个特点：最开始的 Map 是空的，因为里面没有任何元素，往里放元素时会计算 hash 值，计算之后，第 1 个 value 会首先占用一个桶（也称为槽点）位置，后续如果经过计算发现需要落到同一个桶中，那么便会使用链表的形式往后延长，俗称 **“拉链法”**，如图所示：

![img](4.%E7%BB%BF%E7%9B%9F.assets/v2-0a63c9680b379345500dd06ce8e04a4c_720w.jpg)

在图中我们可以看到，有一些槽点是空的，有一些是拉链，有一些是红黑树。

每次遍历一个链表，平均查找的时间复杂度是 O(n)，n 是链表的长度。红黑树有和链表不一样的查找性能，由于**红黑树有自平衡**的特点，可以防止不平衡情况的发生，所以可以始终将查找的**时间复杂度控制在 O(log(n))**。

最初链表还不是很长，所以可能 O(n) 和 O(log(n)) 的区别不大，**但是如果链表越来越长，那么这种区别便会有所体现。所以为了提升查找性能，需要把链表转化为红黑树的形式。**

## volatile的作用

当一个线程更新某个volatile声明的变量时，会通知其他cpu使得缓存失效，从而使得其他cpu想要做更新操作时需要从内存重新读取数据。

不能保证原子性，只能保证变量的有序性和可见性。