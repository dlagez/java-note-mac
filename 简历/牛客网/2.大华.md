### 1.什么是微服务，为啥要微服务，微服务的优缺点。

普通的架构通常是分层架构模式，我在项目中将系统话跟为持久化层、业务逻辑层、web层等。

这些单体式的架构通常以API形式互相访问。耦合紧密导致难以维护。微服务架构就此诞生了。

微服务架构是一种架构风格。它将一个复杂的应用拆分成多个独立自治的服务。

它的缺点是复杂度高、运维复杂、影响性能

### char是否能存中文字符

可以存储：

 java中的char是unicode存储，unicode编码字符集中包含了汉字，所以可以存储中文；

java内部其实是使用的UTF-16的编码，所以是支持大部分非生僻汉字的；

采用Unicode编码集，一个char占用两个字节，而一个中文字符也是两个字节，因此Java中的char是可以表示一个中文字符的；

### 讲讲try，catch，finally，以及finally语句块的作用

ry块包含可能出现异常的代码，出现异常后try块剩余代码不再执行。

catch块用来捕捉异常。catch块可以有多个，通过在catch后加括号(里面的参数写异常的类型)来指定异常的类型，不加括号或者括号里写Exception表示捕捉所有异常。当try块代码发生异常时，程序会根据异常的类型执行第一个符合条件的catch块，如果没找到的话程序会中止并报错。

finally块在所有catch块的后面，包含了始终会执行的代码，准确来说是只要程序没中止就会执行（如果没有符合条件的catch块程序就会中止，finally块也不执行）。finally块代码主要用来释放资源，比如：I/O缓冲区，数据库连接。


### 有哪些问题定位方法

查看bug报错信息。

调试代码

### 默认的类加载器，双亲委派机制以及jvm调优的常用命令和参数

启动类加载器（BootstrapClassloader）

加载一个类的时候，比如这个类是一个我们自己定义的类，它的包名和java内置类的包名不一样，就会使用应用程序类加载器来加载（ApplicationClassloader），但是这个应用程序加载器拿到这个类之后不会立即加载这个类，它会向上委托到启动类加载器。启动类加载器会根据这个类所在的包来判断这个类是不是应该由它来加载。当它发现这个类不归它管的时候，它才会向下请求其他的类加载器来加载。

1.jstack：导出java进程中各个栈内线程信息 eg：jstack -l 12306 >>threadlog.txt 将进程号为12306相关的线程信息导入到threadlog.txt文件中 

2.jinfo pid 查看当前虚拟机的运行参数

3.jconsole/jvisualVM 图形化界面监测jvm进程中线程、cpu、内存、变量 如果连接远程机需要远程机上的项目启动时设置相关参数，本地线程无需设置，如何实现不配置远程主机的启动参数实现监测：

4.jmap 是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生了哪些对象，及其数量，对象内部存值等）。 jmap可以主动导出jvm内存信息，也可以在项目启动时指定在程序内存溢出时自动导出内存信息
`jmap -histo:live `pid 查看进程中对象存活状况 包括数量，占用内存，类型等

5.Memory Analyzer（MAT）分析堆内存DUMP 文件，

6.或者使用jhat是sun 1.6及以上版本中自带的一个用于分析JVM 堆DUMP 文件的工具，基于此工具可分析JVM HEAP 中对象的内存占用情况
jhat -J-Xmx1024M [file] 

eg:  jhat -J-Xmx1024M heapdump.phrof

### 线程池的工作原理，七大参数，四种拒绝策略。

线程池的工作流程
Java线程池的工作流程为：线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在调用execute()添加一个任务时，线程池会按照以下流程执行任务。

如果正在运行的线程数量少于corePoolSize（用户定义的核心线程数），线程池就会立刻创建线程并执行该线程任务
如果正在运行的线程数量大于等于corePoolSize，该任务就将被放入阻塞队列中
在阻塞队列已满且正在运行的线程数量少于maximumPoolSize时，线程池会创建非核心线程立刻执行该线程任务
在阻塞队列已满且正在运行的线程数量大于等于maximumPoolSize时，线程池将拒绝执行该线程任务并抛出RejectException异常
在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中取下一个线程任务继续执行
在非核心线程处于空闲状态的时间超过keepAliveTime时间时，正在运行的线程数量超过corePoolSize，该非核心线程将会被认定为空闲线程并停止。因此，在线程池中所有线程任务都执行完毕后，线程池会收缩到corePoolSize大小。
